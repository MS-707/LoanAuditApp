# Code & Pattern Tracking

## [Repository Structure]
- Design Pattern(s): Modular organization
- Libraries/Frameworks Used: None yet
- Accessibility Enhancements: None yet
- Unit Testing Strategy: Separate `/tests/` directory prepared for future test implementation
- Architectural Considerations: Separation of UI (`/ios_app/`) from business logic (`/core_logic/`), documentation-first approach with `/claude_prompts/` and `/dev_notes/`

## [Loan Audit Engine]
- Design Pattern(s): 
  - Protocol-oriented programming
  - Strategy pattern for rules implementation
  - Composability through rule aggregation
  - Immutable data structures
- Libraries/Frameworks Used: 
  - Foundation (Date, DateFormatter, DateInterval)
- Accessibility Enhancements: 
  - Severity levels with clear textual descriptions
  - Detailed human-readable issue descriptions
- Unit Testing Strategy: 
  - Each rule can be tested independently
  - Mock LoanDetails can be created for specific test scenarios
  - Rules follow single responsibility principle for focused testing
- Architectural Considerations: 
  - Clear separation of data models from business logic
  - Protocol-based design for extensibility
  - Enum-based categorization for consistency
  - Pure functions in rules for predictability and testing

## [Loan Audit Engine Optimization]
- Design Pattern(s): 
  - Inheritance for shared rule implementation (NonPaymentDurationRule base class)
  - Factory methods for test data creation
  - Singleton-like shared formatters
  - Policy pattern for centralized configuration
  - Fluent interface for SeverityScaler
- Libraries/Frameworks Used: 
  - Foundation (NSLocalizedString, NumberFormatter)
  - Swift Concurrency (async/await, TaskGroup)
- Accessibility Enhancements: 
  - Internationalization with NSLocalizedString for all user-facing messages
  - Consistent date and number formatting with locale support
  - Comparable interface for severity levels
- Unit Testing Strategy: 
  - Factory methods create pre-configured test data
  - Equatable conformance for easy result comparison
  - Rule codes for precise identification in tests
  - Base classes for testing related rule types
- Architectural Considerations: 
  - Centralized configuration with AuditPolicy struct
  - Consolidated formatting with AuditFormatters
  - Consistent severity calculation with SeverityScaler
  - Strong public interfaces with well-documented parameters
  - Final classes where inheritance is not intended

## [PDF Loan Parser]
- Design Pattern(s): 
  - Composition over inheritance
  - Builder pattern for constructing LoanDetails incrementally
  - Strategy pattern for different parsing approaches
  - Utility pattern for reusable parsing functions
  - Error handling with custom domain-specific errors
- Libraries/Frameworks Used: 
  - PDFKit (PDFDocument, page handling, text extraction)
  - Foundation (Regular expressions, date handling)
  - NSRegularExpression for pattern matching
- Accessibility Enhancements: 
  - Error messages designed for clear user feedback
  - Robust error handling with specific error types
  - Fallback strategies to ensure data availability
- Unit Testing Strategy: 
  - Clear separation of document reading from parsing logic
  - Field extraction methods designed for independent testing
  - Validation logic centralized for consistent data quality
  - Error conditions clearly specified for test coverage
- Architectural Considerations: 
  - Modular extraction methods for each field type
  - Clear separation of concerns:
    - Document normalization
    - Pattern recognition
    - Date and number parsing
    - Field validation
    - Entity construction
  - Extensibility for different loan servicer formats
  - Privacy-first design with on-device processing

## [AuditReviewContainerView]
- Design Pattern(s): 
  - MVVM architecture with ObservableObject
  - State machine for UI flow management
  - Composition with UIViewControllerRepresentable
  - Dependency injection for preview testing
  - Extension pattern for convenience initializers
- Libraries/Frameworks Used: 
  - SwiftUI (NavigationView, ProgressView, sheet, Toggle)
  - UIKit integration (UIDocumentPickerViewController)
  - Combine for state publication
  - Swift Concurrency (async/await, Task)
  - Conditional compilation for development features
- Accessibility Enhancements: 
  - Comprehensive labels for each workflow state
  - Status announcements during transitions
  - Clear error messaging
  - Minimum tap target sizes
  - State-driven accessibility feedback
  - Color(.system*) for automatic dark mode adaptation
- Unit Testing Strategy: 
  - Separate preview for each UI state
  - Mocked view models for deterministic testing
  - Clear separation of UI and business logic
  - Error state validation
- Architectural Considerations: 
  - Complete workflow coordination
  - Responsive UI with background processing
  - Explicit error handling with user guidance
  - Hidden development shortcuts for testing
  - Security-scoped resource access

## [AuditResultView]
- Design Pattern(s): 
  - Compositional layout with reusable components
  - View modeling with clean data flow
  - Extension pattern for color mapping
  - State management with SwiftUI state property wrapper
- Libraries/Frameworks Used: 
  - SwiftUI (List, Section, DisclosureGroup)
  - UIKit (UIColor) for system colors
- Accessibility Enhancements: 
  - VoiceOver support with clear labels and context
  - Dynamic Type support with appropriate font styles
  - State-dependent accessibility hints
  - Used system colors for Dark Mode safety
- Unit Testing Strategy: 
  - Mock data generation for consistent previews
  - Simple logic tests for color mapping verification
  - Separate previews for different view states
- Architectural Considerations: 
  - Hierarchical organization for related issues
  - Clear separation of row and list components
  - Positive empty state messaging
  - Structured accessibility metadata

## [LoanDetails Model]
- Design Pattern(s): 
  - Value types for data immutability (structs)
  - Nested types for logical grouping
  - Protocol conformance for framework integration
  - Conditional compilation for test support
- Libraries/Frameworks Used: 
  - Foundation (Date, Calendar)
  - Swift standard library (Codable, Equatable)
- Accessibility Enhancements: 
  - Clear documentation for all public properties
  - Logical data organization and field naming
- Unit Testing Strategy: 
  - Static factory method for test data generation
  - Equatable conformance for comparison in tests
  - Codable conformance for serialization testing
- Architectural Considerations: 
  - Shared model between parser and audit systems
  - Strongly typed enumerations (Kind)
  - Clear separation of data from behavior
  - Modular design with computed properties for analysis
  - Sendable conformance for thread safety